---
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Configuring Table & Column names

This chapter is about customizing the name of Database Columns & Tables, not to be confused with JavaScript [Attributes & Models](../terminology.md).

## Table Names

Sequelize will automatically infer Table names from your Model names, unless a table name is provided manually.

:::info

We recommend you name your Model Names using the singular form of a word, in [CamelCase](https://en.wikipedia.org/wiki/Camel_case).
*e.g. User instead of users*

:::

By default, Sequelize automatically pluralizes the model name and uses that as the table name.
This pluralization is done under the hood by a library called [inflection](https://www.npmjs.com/package/inflection),
so that irregular plurals (such as `person -> people`) are computed correctly:

```javascript
class User extends Model {}

User.init(/* options */);

console.log(User.tableName);
// → Users
```

### Snake-case table names

By default, Sequelize does not change the casing of your model name when inferring the table name.

In some databases, it is conventional to have table names in [snake_case](https://en.wikipedia.org/wiki/Snake_case).
You can make Sequelize generate a snake_cased table name by setting the [`underscored`](pathname:///api/interfaces/ModelOptions.html#underscored) option.

:::info

The `underscored` option also impacts Column Names. [See *Snake-case column names*](#snake-case-column-names).

:::

```javascript
class User extends Model {}

User.init({ /* attributes */ }, {
  underscored: true,
});

console.log(User.tableName);
// → users (notice the lowercase u)
```

This behavior can also be defined globally by setting the option in the Sequelize constructor:

```js
const sequelize = new Sequelize('sqlite::memory:', {
  define: {
    underscored: true,
  },
});

class User extends Model {}

User.init(/* options */);

console.log(User.tableName);
// → users
```

### Enforcing the table name to be equal to the model name

You can stop the auto-pluralization performed by Sequelize using the [`freezeTableName: true`](pathname:///api/interfaces/ModelOptions.html#freezeTableName) option.
Sequelize will use the model name as the table name, without any modifications.

Note that setting `freezeTableName` also causes Sequelize to ignore the `underscored` option for table names.

```javascript
class User extends Model {}

User.init({ /* attributes */ }, {
  freezeTableName: true,
});

console.log(User.tableName);
// → User
```

This behavior can also be defined globally by setting the option in the Sequelize constructor:

```js
const sequelize = new Sequelize('sqlite::memory:', {
  define: {
    freezeTableName: true,
  },
});

class User extends Model {}

User.init(/* options */);

console.log(User.tableName);
// → User
```

### Manually setting the table name

You can simply tell Sequelize the name of the table directly as well.
This bypasses any automatic table name generation option. Neither snake_casing nor pluralization will be done:

```js
sequelize.define('User', {
  // ... (attributes)
}, {
  tableName: 'Employees'
});
```

## Column Names

By default, Sequelize will use the name of your attributes as-is as the name of your columns.

### Snake-case column names

Just like for [table names](#snake-case-table-names), the `underscored` option can be used
to make Sequelize infer [snake_cased](https://en.wikipedia.org/wiki/Snake_case) column names from the attribute names.

This option applies to any attribute that does not [explicitly set the `field` option](#manually-setting-the-column-name),
including attributes automatically generated by Sequelize such as [association](../associations/overview.md) foreign-keys and [auto-generated timestamps](./auto-timestamps.mdx).

---

In the following example, we have the models User and Task, both using the `underscored` option.
We also have a [One-to-Many relationship](../associations/one-to-many.mdx) between them.

<Tabs>
<TabItem value="ts" label="TypeScript">

```typescript
import { Model, InferAttributes, InferCreationAttributes, CreationOptional } from '@sequelize/core';

class User extends Model {
  id: CreationOptional<number>;
  createdAt: CreationOptional<Date>;
  updatedAt: CreationOptional<Date>;
  username: string | null;
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true,
  },
  username: Sequelize.STRING,
  createdAt: Sequelize.DATE,
  updatedAt: Sequelize.DATE,
}, {
  underscored: true,
});

class Task extends Model {
  id: CreationOptional<number>;
  createdAt: CreationOptional<Date>;
  updatedAt: CreationOptional<Date>;
  title: string | null;

  // added by User.hasMany(Task), Task.belongsTo(User)
  UserId: number;
}

Task.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true,
  },
  title: Sequelize.STRING,
  createdAt: Sequelize.DATE,
  updatedAt: Sequelize.DATE,
}, {
  underscored: true,
});

User.hasMany(Task);
Task.belongsTo(User);
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
const User = sequelize.define('User', { username: Sequelize.STRING }, {
  underscored: true,
});

const Task = sequelize.define('Task', { title: Sequelize.STRING }, {
  underscored: true,
});

User.hasMany(Task);
Task.belongsTo(User);
```

</TabItem>
</Tabs>

:::info About Foreign Key Attributes

[Association definition](../associations/overview.md) methods automatically add
the necessary Foreign Key attributes to your models.

By default, the name of this attribute is equal to the name of the target model + the name of its primary key. In this example,
 an attribute called `UserId` is added on the `Task` model.

:::

Without the `underscored` option, Sequelize would automatically define:

* A [`createdAt`](./auto-timestamps.mdx) attribute for each model, pointing to a column named `createdAt` in each table.
* An [`updatedAt`](./auto-timestamps.mdx) attribute for each model, pointing to a column named `updatedAt` in each table.
* A `UserId` attribute in the `Task` model, pointing to a column named `UserId` in the task table.

With the `underscored` option enabled, Sequelize will instead define:

* A [`createdAt`](./auto-timestamps.mdx) attribute for each model, pointing to a column named `created_at` in each table.
* An [`updatedAt`](./auto-timestamps.mdx) attribute for each model, pointing to a column named `updated_at` in each table.
* A `UserId` attribute in the `Task` model, pointing to a column named `user_id` in the task table.

Note that in both cases the fields are still [camelCase](https://en.wikipedia.org/wiki/Camel_case) in the JavaScript side; this option only changes how these fields are mapped to the database itself. The `field` option of every attribute is set to their snake_case version, but the attribute itself remains camelCase.

With `underscored: true`, calling `sequelize.sync()` after the above code will execute the following:

```sql
CREATE TABLE IF NOT EXISTS "users" (
  "id" SERIAL,
  "username" VARCHAR(255),
  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  PRIMARY KEY ("id")
);

CREATE TABLE IF NOT EXISTS "tasks" (
  "id" SERIAL,
  "title" VARCHAR(255),
  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "user_id" INTEGER REFERENCES "users" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
  PRIMARY KEY ("id")
);
```

### Manually setting the column name

It is also possible to manually set the name of a column by setting the `field` option on an attribute.
This name takes precedences and will be used as-is. The `underscored` option is ignored for this column.

```javascript
const User = sequelize.define('User', {
  // this sets the attribute name to 'firstName'
  firstName: {
    type: Sequelize.STRING,

    // this sets the corresponding column name to 'name'
    field: 'name',
  }
}, {
  // model options
});
```

## Singular vs. Plural Conventions

At a first glance, it can be confusing whether the singular form or plural form of a name shall be used around in Sequelize. This section aims at clarifying that a bit.

Recall that Sequelize uses a library called [inflection](https://www.npmjs.com/package/inflection) under the hood, so that irregular plurals (such as `person -> people`) are computed correctly. However, if you're working in another language, you may want to define the singular and plural forms of names directly; sequelize allows you to do this with some options.

### When defining models

Models should be defined with the singular form of a word. Example:

```js
sequelize.define('Foo', { name: DataTypes.STRING });
```

Above, the model name is `Foo` (singular), and the respective table name is `Foos`, since Sequelize automatically gets the plural for the table name.

### When defining a reference key in a model

```js
sequelize.define('Foo', {
  name: DataTypes.STRING,
  barId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: "bars",
      key: "id"
    },
    onDelete: "CASCADE"
  },
});
```

In the above example we are manually defining a key that references another model. It's not usual to do this, but if you have to, you should use the table name there. This is because the reference is created upon the referencced table name. In the example above, the plural form was used (`bars`), assuming that the `bar` model was created with the default settings (making its underlying table automatically pluralized).

### When retrieving data from eager loading

When you perform an `include` in a query, the included data will be added to an extra field in the returned objects, according to the following rules:

* When including something from a single association (`hasOne` or `belongsTo`) - the field name will be the singular version of the model name;
* When including something from a multiple association (`hasMany` or `belongsToMany`) - the field name will be the plural form of the model.

In short, the name of the field will take the most logical form in each situation.

Examples:

```js
// Assuming Foo.hasMany(Bar)
const foo = Foo.findOne({ include: Bar });
// foo.bars will be an array
// foo.bar will not exist since it doens't make sense

// Assuming Foo.hasOne(Bar)
const foo = Foo.findOne({ include: Bar });
// foo.bar will be an object (possibly null if there is no associated model)
// foo.bars will not exist since it doens't make sense

// And so on.
```

### Overriding singulars and plurals when defining aliases

When defining an alias for an association, instead of using simply `{ as: 'myAlias' }`, you can pass an object to specify the singular and plural forms:

```js
Project.belongsToMany(User, {
  as: {
    singular: 'líder',
    plural: 'líderes'
  }
});
```

If you know that a model will always use the same alias in associations, you can provide the singular and plural forms directly to the model itself:

```js
const User = sequelize.define('User', { /* ... */ }, {
  name: {
    singular: 'líder',
    plural: 'líderes',
  }
});
Project.belongsToMany(User);
```

The mixins added to the user instances will use the correct forms. For example, instead of `project.addUser()`, Sequelize will provide `project.getLíder()`. Also, instead of `project.setUsers()`, Sequelize will provide `project.setLíderes()`.

Note: recall that using `as` to change the name of the association will also change the name of the foreign key. Therefore it is recommended to also specify the foreign key(s) involved directly in this case.

```js
// Example of possible mistake
Invoice.belongsTo(Subscription, { as: 'TheSubscription' });
Subscription.hasMany(Invoice);
```

The first call above will establish a foreign key called `theSubscriptionId` on `Invoice`. However, the second call will also establish a foreign key on `Invoice` (since as we know, `hasMany` calls places foreign keys in the target model) - however, it will be named `subscriptionId`. This way you will have both `subscriptionId` and `theSubscriptionId` columns.

The best approach is to choose a name for the foreign key and place it explicitly in both calls. For example, if `subscription_id` was chosen:

```js
// Fixed example
Invoice.belongsTo(Subscription, { as: 'TheSubscription', foreignKey: 'subscription_id' });
Subscription.hasMany(Invoice, { foreignKey: 'subscription_id' });
```
